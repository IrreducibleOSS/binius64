// types.rs - Public types for the prover interface

/// Witness data for proof generation
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Witness {
    values: Vec<u64>,
}

impl Witness {
    /// Create a new witness from a vector of values
    pub fn new(values: Vec<u64>) -> Self {
        Self { values }
    }

    /// Create a witness from raw bytes
    pub fn from_bytes(bytes: &[u8]) -> Self {
        // Convert bytes to u64 values (simple implementation for now)
        let values = bytes.iter().map(|&b| b as u64).collect();
        Self { values }
    }

    /// Get the length of the witness
    pub fn len(&self) -> usize {
        self.values.len()
    }

    /// Check if the witness is empty
    pub fn is_empty(&self) -> bool {
        self.values.is_empty()
    }

    /// Get the values
    pub fn values(&self) -> &[u64] {
        &self.values
    }

    /// Convert to bytes
    pub fn as_bytes(&self) -> Vec<u8> {
        self.values.iter().map(|&v| v as u8).collect()
    }
}

/// A proof generated by the prover
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Proof {
    data: Vec<u8>,
}

impl Proof {
    /// Create a proof from raw bytes
    pub fn from_bytes(bytes: &[u8]) -> Self {
        Self {
            data: bytes.to_vec(),
        }
    }

    /// Get the length of the proof in bytes
    pub fn len(&self) -> usize {
        self.data.len()
    }

    /// Check if the proof is empty
    pub fn is_empty(&self) -> bool {
        self.data.is_empty()
    }

    /// Convert the proof to bytes
    pub fn to_bytes(&self) -> Vec<u8> {
        self.data.clone()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_witness_creation() {
        // This test will fail initially (TDD - Red phase)
        let witness = Witness::new(vec![1, 0, 1, 1]);
        assert_eq!(witness.len(), 4);
    }

    #[test]
    fn test_witness_from_bytes() {
        let witness = Witness::from_bytes(&[0xFF, 0xAA, 0x55]);
        assert_eq!(witness.as_bytes(), &[0xFF, 0xAA, 0x55]);
    }

    #[test]
    fn test_witness_values() {
        let values = vec![42, 17, 255];
        let witness = Witness::new(values.clone());
        assert_eq!(witness.values(), &values);
    }

    #[test]
    fn test_proof_creation() {
        let proof = Proof::from_bytes(&[0x01, 0x02, 0x03]);
        assert_eq!(proof.len(), 3);
    }

    #[test]
    fn test_proof_serialization() {
        let proof = Proof::from_bytes(&[0xDE, 0xAD, 0xBE, 0xEF]);
        assert_eq!(proof.to_bytes(), vec![0xDE, 0xAD, 0xBE, 0xEF]);
    }
}