// Copyright 2025 Irreducible Inc.

use binius_field::{BinaryField, ExtensionField, Field, TowerField};
use binius_math::multilinear::eq::eq_ind;
use binius_transcript::{
	VerifierTranscript,
	fiat_shamir::{CanSample, Challenger},
};
use binius_utils::DeserializeBytes;

use crate::{
	fri::{FRIParams, verify::FRIVerifier},
	merkle_tree::MerkleTreeScheme,
	protocols::sumcheck::{RoundCoeffs, RoundProof, SumcheckOutput},
};

const NUM_ROUND_COEFFS: usize = 3;

/// Determines for each round if a FRI commitment was made depending on folding arities.
///
/// FRI can be optimized by folding multiple rounds at once. The FriFolder struct
/// expects the arities for each round to be provided. During the basefold verification,
/// we must check only those rounds where a commitment was made.
///
/// ## Arguments
///
/// * `fri_fold_arities` - The arities for each FRI round
/// * `num_basefold_rounds` - The number of basefold rounds
///
/// # Returns
///
/// A vector of booleans, where true indicates a FRI commitment was made in that round.
fn is_fri_commit_round(
	fri_fold_arities: &[usize],
	num_basefold_rounds: usize,
) -> Result<Vec<bool>, Box<dyn std::error::Error>> {
	let mut result = vec![false; num_basefold_rounds];
	let mut result_idx = 0;
	for arity in fri_fold_arities {
		result_idx += arity;
		if result_idx > 0 && result_idx <= num_basefold_rounds {
			result[result_idx - 1] = true;
		}
	}

	Ok(result)
}

/// Verifies the transcript of a basefold proof generated by the prover.
///
/// The verifier goes through the transcript, verifying each stage of the
/// FRI and Sumcheck in parallel.
///
/// The verifier returns the final FRI value, expected sumcheck claim, and
/// the challenges used in the sumcheck rounds.
///
/// ## Arguments
///
/// * `codeword_commitment` - The commitment to the codeword
/// * `transcript` - The transcript containing the prover's messages and randomness for challenges
/// * `evaluation_claim` - The claimed evaluation of the multilinear polynomial at the evaluation
///   point
/// * `fri_params` - The FRI parameters
/// * `vcs` - The Merkle tree scheme
/// * `n_vars` - The number of variables in the multilinear polynomial
pub fn verify_transcript<F, FA, VCS, TranscriptChallenger>(
	codeword_commitment: VCS::Digest,
	transcript: &mut VerifierTranscript<TranscriptChallenger>,
	evaluation_claim: F,
	fri_params: &FRIParams<F, FA>,
	vcs: &VCS,
	n_vars: usize,
) -> Result<(F, SumcheckOutput<F>), Box<dyn std::error::Error>>
where
	F: Field + BinaryField + ExtensionField<FA> + TowerField,
	FA: BinaryField,
	TranscriptChallenger: Challenger + Clone,
	VCS: MerkleTreeScheme<F, Digest: DeserializeBytes>,
{
	let mut challenges = Vec::with_capacity(n_vars);
	let fri_commit_rounds = is_fri_commit_round(fri_params.fold_arities(), n_vars)?;
	let mut round_commitments = vec![];
	let mut sum = evaluation_claim;

	for is_commit_round in fri_commit_rounds {
		let round_proof = RoundProof(RoundCoeffs(
			transcript
				.message()
				.read_scalar_slice::<F>(NUM_ROUND_COEFFS)?,
		));

		let challenge = transcript.sample();

		let round_coeffs = round_proof.recover(sum);

		sum = round_coeffs.evaluate(challenge);

		challenges.push(challenge);

		if is_commit_round {
			round_commitments.push(transcript.message().read()?);
		}
	}

	let fri_verifier =
		FRIVerifier::new(fri_params, vcs, &codeword_commitment, &round_commitments, &challenges)?;

	let fri_oracle = fri_verifier.verify(transcript)?;

	Ok((
		fri_oracle,
		SumcheckOutput {
			eval: sum,
			challenges,
		},
	))
}

/// Verifies that the final FRI oracle is consistent with the sumcheck
///
/// This assertion verifies that the FRI and Sumcheck proof belong to the same
/// commitment. It should be called after the transcript has been verified.
///
/// ## Arguments
///
/// * `fri_final_oracle` - The final FRI oracle
/// * `sumcheck_final_claim` - The final sumcheck claim
/// * `evaluation_point` - The evaluation point
/// * `challenges` - The challenges used in the sumcheck rounds
///
/// # Returns
///
/// A boolean indicating if the final FRI oracle is consistent with the sumcheck claim.
pub fn final_basefold_assertion<F: Field>(
	fri_final_oracle: F,
	sumcheck_final_claim: F,
	evaluation_point: &[F],
	challenges: &[F],
) -> bool {
	fri_final_oracle * eq_ind(evaluation_point, challenges) == sumcheck_final_claim
}
