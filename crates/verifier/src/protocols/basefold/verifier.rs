use binius_field::{BinaryField, ExtensionField, Field, TowerField};
use binius_math::multilinear::eq::eq_ind;
use binius_transcript::{
	VerifierTranscript,
	fiat_shamir::{CanSample, Challenger},
};
use binius_utils::DeserializeBytes;

use crate::{
	fri::{FRIParams, verify::FRIVerifier},
	merkle_tree::MerkleTreeScheme,
	protocols::basefold::utils::verify_sumcheck_round,
};

/// Determines at which rounds the prover is expected to commit given the FRI
/// folding arities
pub fn is_fri_commit_round(fri_fold_arities: &[usize], num_basefold_rounds: usize) -> Vec<bool> {
	let mut result = vec![false; num_basefold_rounds];
	let mut result_idx = 0;
	for arity in fri_fold_arities {
		result_idx += arity;
		result[result_idx - 1] = true;
	}

	result
}

/// Verifies the transcript of a basefold proof generated by the prover.
///
/// The verifier goes through the trascript, verifying each stage of the
/// FRI and Sumcheck in parallel.
///
/// The verifier returns the final FRI value, expected sumcheck claim, and
/// the challenges used in the sumcheck rounds.
pub fn verify_transcript<F, FA, VCS, TranscriptChallenger>(
	codeword_commitment: VCS::Digest,
	transcript: &mut VerifierTranscript<TranscriptChallenger>,
	evaluation_claim: F,
	fri_params: &FRIParams<F, FA>,
	vcs: &VCS,
	n_vars: usize,
) -> Result<(F, F, Vec<F>), String>
where
	F: Field + BinaryField + ExtensionField<FA> + TowerField,
	FA: BinaryField,
	TranscriptChallenger: Challenger + Clone,
	VCS: MerkleTreeScheme<F, Digest: DeserializeBytes>,
{
	// retrieve the challenges and further commitments from the transcript
	let mut basefold_challenges: Vec<F> = Vec::with_capacity(fri_params.n_fold_rounds());

	// infer sumcheck claim from transcript
	let verifier_computed_sumcheck_claim = evaluation_claim;

	// rounds the prover is expected to have committed at
	let commit_rounds: Vec<bool> = is_fri_commit_round(fri_params.fold_arities(), n_vars);

	let mut expected_sumcheck_round_claim = verifier_computed_sumcheck_claim;
	let mut round_commitments = vec![];

	// retrace footsteps through basefold
	for commit_round in commit_rounds.iter() {
		// get round message from transcript
		let round_msg = transcript
			.message()
			.read_scalar_slice::<F>(3)
			.expect("failed to read round message");

		// sample challenge from transcript
		let basefold_challenge = transcript.sample();

		// verify a valid sumcheck round message per the expected sumcheck claim
		let round_sum = round_msg[0] + round_msg[1];
		let next_claim = verify_sumcheck_round(
			round_sum,
			expected_sumcheck_round_claim,
			round_msg,
			basefold_challenge,
		);

		// update expected sumcheck claim for next round
		expected_sumcheck_round_claim = next_claim;

		// add challenge to list of challenges
		basefold_challenges.push(basefold_challenge);

		// retrieve commitment depending on current round FRI folding arity
		if *commit_round {
			round_commitments.push(
				transcript
					.message()
					.read()
					.expect("failed to read commitment"),
			);
		}
	}

	// Init FRI verifier
	let fri_verifier = FRIVerifier::new(
		fri_params,
		vcs,
		&codeword_commitment,
		&round_commitments,
		&basefold_challenges,
	)
	.expect("failed to create FRI verifier");

	// By verifying FRI, the verifier checks that c == t(r'_0, ..., r'_{\ell-1})
	// note that the prover is claiming that the final_message is [c]
	let mut verifier_challenger = transcript;
	let final_fri_oracle = fri_verifier
		.verify(&mut verifier_challenger)
		.expect("failed to verify FRI");

	Ok((final_fri_oracle, expected_sumcheck_round_claim, basefold_challenges))
}

/// Verifies that the final FRI oracle is consistent with the sumcheck
///
/// This assertion verifies that the FRI and Sumcheck proof belong to the same
/// commitment. It should be called after the transcript has been verified.
pub fn verify_final_basefold_assertion<F: Field>(
	fri_final_oracle: F,
	sumcheck_final_claim: F,
	evaluation_point: &[F],
	basefold_challenges: &[F],
) -> bool {
	fri_final_oracle * eq_ind(&evaluation_point, &basefold_challenges) == sumcheck_final_claim
}
