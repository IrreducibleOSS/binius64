use binius_field::{BinaryField, ExtensionField, Field, TowerField};
use binius_math::multilinear::eq::eq_ind;
use binius_transcript::{
	VerifierTranscript,
	fiat_shamir::{CanSample, Challenger},
};
use binius_utils::DeserializeBytes;

use crate::{
	fri::{FRIParams, verify::FRIVerifier},
	merkle_tree::MerkleTreeScheme,
	protocols::sumcheck::{SumcheckOutput, common::RoundCoeffs},
};

/// Determines at which rounds the prover is expected to commit given the FRI folding arities
fn is_fri_commit_round(fri_fold_arities: &[usize], num_basefold_rounds: usize) -> Vec<bool> {
	let mut result = vec![false; num_basefold_rounds];
	let mut result_idx = 0;
	for arity in fri_fold_arities {
		result_idx += arity;
		result[result_idx - 1] = true;
	}

	result
}

/// Verifies the transcript of a basefold proof generated by the prover.
///
/// The verifier goes through the trascript, verifying each stage of the
/// FRI and Sumcheck in parallel.
///
/// The verifier returns the final FRI value, expected sumcheck claim, and
/// the challenges used in the sumcheck rounds.
///
/// ## Arguments
///
/// * `codeword_commitment` - The commitment to the codeword
/// * `transcript` - The transcript containing the prover's messages and randomness for challenges
/// * `evaluation_claim` - The claimed evaluation of the multilinear polynomial at the evaluation
///   point
/// * `fri_params` - The FRI parameters
/// * `vcs` - The Merkle tree scheme
pub fn verify_transcript<F, FA, VCS, TranscriptChallenger>(
	codeword_commitment: VCS::Digest,
	transcript: &mut VerifierTranscript<TranscriptChallenger>,
	evaluation_claim: F,
	fri_params: &FRIParams<F, FA>,
	vcs: &VCS,
	n_vars: usize,
) -> Result<(F, SumcheckOutput<F>), Box<dyn std::error::Error>>
where
	F: Field + BinaryField + ExtensionField<FA> + TowerField,
	FA: BinaryField,
	TranscriptChallenger: Challenger + Clone,
	VCS: MerkleTreeScheme<F, Digest: DeserializeBytes>,
{
	let mut basefold_challenges = Vec::with_capacity(fri_params.n_fold_rounds());

	let verifier_computed_sumcheck_claim = evaluation_claim;

	let fri_commit_rounds = is_fri_commit_round(fri_params.fold_arities(), n_vars);

	let mut expected_sumcheck_round_claim = verifier_computed_sumcheck_claim;
	let mut round_commitments = vec![];

	for fri_commit_round in fri_commit_rounds.iter() {
		let round_message = RoundCoeffs::<F>(transcript.message().read_scalar_slice::<F>(3)?);

		let basefold_challenge = transcript.sample();

		// Compute what the sumcheck should have been based on the round message
		// This allows us to continue verification even if the sumcheck constraint
		// isn't explicitly satisfied, deferring validation to the final assertion
		let sum_check = round_message.evaluate(F::ZERO) + round_message.evaluate(F::ONE);
		if sum_check != expected_sumcheck_round_claim {
			return Err("Sumcheck constraint not satisfied".into());
		}

		// Update expected claim based on the actual evaluation at the challenge point
		expected_sumcheck_round_claim = round_message.evaluate(basefold_challenge);

		basefold_challenges.push(basefold_challenge);

		if *fri_commit_round {
			round_commitments.push(transcript.message().read()?);
		}
	}

	// Init FRI verifier
	let fri_verifier = FRIVerifier::new(
		fri_params,
		vcs,
		&codeword_commitment,
		&round_commitments,
		&basefold_challenges,
	)?;

	// By verifying FRI, the verifier checks that c == t(r'_0, ..., r'_{\ell-1})
	// note that the prover is claiming that the final_message is [c]
	let verifier_challenger = transcript;
	let final_fri_oracle = fri_verifier.verify(verifier_challenger)?;

	let sumcheck_output = SumcheckOutput {
		eval: expected_sumcheck_round_claim,
		challenges: basefold_challenges,
	};

	Ok((final_fri_oracle, sumcheck_output))
}

/// Verifies that the final FRI oracle is consistent with the sumcheck
///
/// This assertion verifies that the FRI and Sumcheck proof belong to the same
/// commitment. It should be called after the transcript has been verified.
///
/// ## Arguments
///
/// * `fri_final_oracle` - The final FRI oracle
/// * `sumcheck_final_claim` - The final sumcheck claim
/// * `evaluation_point` - The evaluation point
/// * `basefold_challenges` - The challenges used in the sumcheck rounds
pub fn verify_final_basefold_assertion<F: Field>(
	fri_final_oracle: F,
	sumcheck_final_claim: F,
	evaluation_point: &[F],
	basefold_challenges: &[F],
) -> bool {
	fri_final_oracle * eq_ind(evaluation_point, basefold_challenges) == sumcheck_final_claim
}
