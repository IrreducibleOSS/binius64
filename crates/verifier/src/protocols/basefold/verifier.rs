use binius_field::{BinaryField, ExtensionField, Field, TowerField};
use binius_math::multilinear::eq::eq_ind;
use binius_transcript::{
	VerifierTranscript,
	fiat_shamir::{CanSample, Challenger},
};
use binius_utils::DeserializeBytes;

use crate::{
	fri::{FRIParams, verify::FRIVerifier},
	merkle_tree::MerkleTreeScheme,
	protocols::sumcheck::{RoundCoeffs, RoundProof, SumcheckOutput},
};

fn is_fri_commit_round(fri_fold_arities: &[usize], num_basefold_rounds: usize) -> Vec<bool> {
	let mut result = vec![false; num_basefold_rounds];
	let mut result_idx = 0;
	for arity in fri_fold_arities {
		result_idx += arity;
		result[result_idx - 1] = true;
	}

	result
}

/// Verifies the transcript of a basefold proof generated by the prover.
///
/// The verifier goes through the trascript, verifying each stage of the
/// FRI and Sumcheck in parallel.
///
/// The verifier returns the final FRI value, expected sumcheck claim, and
/// the challenges used in the sumcheck rounds.
///
/// ## Arguments
///
/// * `codeword_commitment` - The commitment to the codeword
/// * `transcript` - The transcript containing the prover's messages and randomness for challenges
/// * `evaluation_claim` - The claimed evaluation of the multilinear polynomial at the evaluation
///   point
/// * `fri_params` - The FRI parameters
/// * `vcs` - The Merkle tree scheme
pub fn verify_transcript<F, FA, VCS, TranscriptChallenger>(
	codeword_commitment: VCS::Digest,
	transcript: &mut VerifierTranscript<TranscriptChallenger>,
	evaluation_claim: F,
	fri_params: &FRIParams<F, FA>,
	vcs: &VCS,
	n_vars: usize,
) -> Result<(F, SumcheckOutput<F>), Box<dyn std::error::Error>>
where
	F: Field + BinaryField + ExtensionField<FA> + TowerField,
	FA: BinaryField,
	TranscriptChallenger: Challenger + Clone,
	VCS: MerkleTreeScheme<F, Digest: DeserializeBytes>,
{
	let mut challenges = Vec::with_capacity(n_vars);
	let fri_commit_rounds = is_fri_commit_round(fri_params.fold_arities(), n_vars);
	let mut round_commitments = vec![];
	let mut sum = evaluation_claim;

	for is_commit_round in fri_commit_rounds {
		let round_proof = RoundProof(RoundCoeffs(transcript.message().read_scalar_slice::<F>(3)?));

		let challenge = transcript.sample();

		let round_coeffs = round_proof.recover(sum);

		sum = round_coeffs.evaluate(challenge);

		challenges.push(challenge);

		if is_commit_round {
			round_commitments.push(transcript.message().read()?);
		}
	}

	let fri_verifier =
		FRIVerifier::new(fri_params, vcs, &codeword_commitment, &round_commitments, &challenges)?;

	let fri_oracle = fri_verifier.verify(transcript)?;

	Ok((
		fri_oracle,
		SumcheckOutput {
			eval: sum,
			challenges,
		},
	))
}

/// Verifies that the final FRI oracle is consistent with the sumcheck
///
/// This assertion verifies that the FRI and Sumcheck proof belong to the same
/// commitment. It should be called after the transcript has been verified.
///
/// ## Arguments
///
/// * `fri_final_oracle` - The final FRI oracle
/// * `sumcheck_final_claim` - The final sumcheck claim
/// * `evaluation_point` - The evaluation point
/// * `challenges` - The challenges used in the sumcheck rounds
pub fn final_basefold_assertion<F: Field>(
	fri_final_oracle: F,
	sumcheck_final_claim: F,
	evaluation_point: &[F],
	challenges: &[F],
) -> bool {
	fri_final_oracle * eq_ind(evaluation_point, challenges) == sumcheck_final_claim
}
