// Copyright 2025 Irreducible Inc.
//! Utilities for hash circuit examples

use anyhow::{Result, ensure};
use rand::{RngCore, SeedableRng, rngs::StdRng};

/// Default message size for hash circuit examples (1 KiB)
///
/// This value is chosen as a reasonable default that:
/// - Is large enough to demonstrate performance characteristics
/// - Small enough for quick testing and development
/// - Aligns with common block sizes in many systems
pub const DEFAULT_HASH_MESSAGE_BYTES: usize = 1024;

/// Standard seed for reproducible random message generation
pub const DEFAULT_RANDOM_SEED: u64 = 42;

/// Determines the maximum message size for hash circuits from command-line arguments
///
/// This function consolidates the common logic used across all hash circuit examples
/// for determining the circuit capacity based on command-line arguments.
///
/// # Arguments
/// * `max_bytes_param` - Optional maximum size parameter from circuit configuration
///
/// # Returns
/// * `Ok(usize)` - The determined maximum message size in bytes
/// * `Err` - If the resulting size is 0 or invalid
///
/// # Behavior
/// If no explicit max_bytes parameter is provided, this function:
/// 1. Checks for `--message-string` and uses its length
/// 2. Otherwise checks for `--message-len`
/// 3. Falls back to `DEFAULT_HASH_MESSAGE_BYTES` (1024)
pub fn determine_hash_max_bytes_from_args(max_bytes_param: Option<usize>) -> Result<usize> {
	let max_bytes = max_bytes_param.unwrap_or_else(|| {
		let args: Vec<String> = std::env::args().collect();
		let mut message_len = None;
		let mut message_string = None;

		for i in 0..args.len() {
			if args[i] == "--message-len" && i + 1 < args.len() {
				message_len = args[i + 1].parse::<usize>().ok();
			} else if args[i] == "--message-string" && i + 1 < args.len() {
				message_string = Some(args[i + 1].clone());
			}
		}

		if let Some(msg_string) = message_string {
			msg_string.len()
		} else {
			message_len.unwrap_or(DEFAULT_HASH_MESSAGE_BYTES)
		}
	});

	ensure!(max_bytes > 0, "Message length must be positive");
	Ok(max_bytes)
}

/// Generate message bytes from instance parameters.
///
/// Returns either the UTF-8 bytes of the provided string or randomly generated bytes.
///
/// # Arguments
/// * `message_string` - Optional UTF-8 string to hash
/// * `message_len` - Optional length for random message generation (defaults to 1KiB)
pub fn generate_message_bytes(
	message_string: Option<String>,
	message_len: Option<usize>,
) -> Vec<u8> {
	if let Some(message_string) = message_string {
		message_string.as_bytes().to_vec()
	} else {
		let mut rng = StdRng::seed_from_u64(DEFAULT_RANDOM_SEED);
		let len = message_len.unwrap_or(DEFAULT_HASH_MESSAGE_BYTES);
		let mut message_bytes = vec![0u8; len];
		rng.fill_bytes(&mut message_bytes);
		message_bytes
	}
}

/// Zero-pad message to maximum length.
///
/// Ensures the message doesn't exceed max_len and pads with zeros to reach max_len.
///
/// # Arguments
/// * `message_bytes` - The original message bytes
/// * `max_len` - The target length after padding
///
/// # Returns
/// * `Ok(Vec<u8>)` - The padded message
/// * `Err` - If the message exceeds max_len
pub fn zero_pad_message(message_bytes: Vec<u8>, max_len: usize) -> Result<Vec<u8>> {
	ensure!(
		message_bytes.len() <= max_len,
		"Message length ({}) exceeds maximum ({})",
		message_bytes.len(),
		max_len
	);

	let mut padded = message_bytes;
	padded.resize(max_len, 0);
	Ok(padded)
}
